\chapter{Аналитическая часть}


\section{Способы определения моделей}

В системах трехмерного моделирования используются широко используется, каркасные, поверхностные и объемные твердотельные модели. Правильный выбор метода определения моделей на сцене является ключевым фактором, определяющим размер и визуализацию модели в сцене, что в свою очередь способствует точному представлению их формы и размеров.

\subsection{Каркасная модель}
Каркасные модели представляют объекты, созданные из соединенных
ребер, похожие на объекты, сделанные из проволоки. В таких моделях грани объекта не определены, но их границы представлены ребрами. Каркасная модель не имеет поверхности, которые бы скрывали ребра, поэтому она выглядит прозрачной \cite{model_geom}.

Этот тип моделирования относится к категории наиболее примитивных и имеет ряд значительных ограничений. Большинство из них связаны с отсутствием информации о гранях, образованных линиями, а также с невозможностью разграничить внутреннюю и внешнюю зоны в изображении твердого тела, это хорошо видно на рисунке \ref{img-mod1}. Несмотря на ограничения, каркасная модель занимает меньше памяти и является достаточно эффективной для выполнения простых задач. Этот тип представления часто применяется не столько для моделирования, сколько для отображения моделей в качестве одного из методов визуализации. Наиболее широко каркасное моделирование используется для имитации траектории движения инструмента, выполняющего несложные операции \cite{model_geom_01}.

\textbf{Недостатки каркасной модели, обсуждаются в \cite{model_geom_01}:}
\begin{enumerate}
      \item \textit{неоднозначность} --- визуализация всех ребер может привести к неясности и непредсказуемым результатам. Видимые грани и невидимые трудно отличить;
      \item \textit{затруднения в идентификации криволинейных граней} --- каркасная модель не способна адекватно представить поверхности с непостоянной кривизной, например, боковые поверхности цилиндров, что может вводить в заблуждение;
      \item \textit{ограниченность в обнаружении взаимодействий между компонентами} --- из-за отсутствия информации о поверхностях, модель не может предсказать возможные конфликты между гранями объекта; 
    		
    		%(Ограничения в выявлении взаимодействий между элементами: отсутствие информации о поверхностях в каркасной модели препятствует анализу возможных взаимных влияний между гранями объекта.)
    \item \textit{трудности в вычислении физических характеристик из-за простоты модели};
   	\item \textit{невозможность создания градационных изображений} --- каркасная модель не предполагает создания тоновых изображений, которые требуют затенения граней, а не ребер.
\end{enumerate}
   
\img{50mm}{mod1}{Пример каркасной модели.}

  

\subsection{Поверхностная модель}

Поверхностные модели включают как ребра, так и поверхности, что позволяет более точно представить объект, чем каркасные модели. В поверхностных моделях грани, расположенные спереди, перекрывают грани, находящиеся на заднем плане, это можно увидеть на рисунке \ref{img-mod2}. Когда изображение выводится на монитор, можно получить более реалистичное представление трехмерного объекта. Поверхностные модели имеют объем, но не имеют массы \cite{model_geom}

Рассмотрев \cite{model_geom_01}, можно выделить следующие преимущества по сравнению с каркасными моделями:

\img{50mm}{mod2}{Пример поверхностной модели.} 

\begin{enumerate}
	\item способность распознавания и изображения сложных криволинейных граней;
	\item изображение грани для получения тоновых изображений;
	\item особые построения на поверхности (отверстия);
	\item возможность получения качественного изображения.
\end{enumerate}


В основу поверхностной модели положены два основных математических положения:
\begin{itemize}
\item любую поверхность можно аппроксимировать
многогранником, каждая грань которого является простейшим плоским
многоугольником \cite{model_geom_01};
\item наряду с плоскими многоугольниками в модели допускаются поверхности второго порядка и аналитически не описываемые поверхности, форму которых можно определить с помощью различных методов аппроксимации и интерполяции. В отличие от каркасного моделирования каждый объект имеет внутреннюю и внешнюю часть \cite{model_geom_01}.
\end{itemize}

%Поверхностные модели широко применяются в разработке динамических поверхностей, которые взаимодействуют с внешней средой. Примеры таких поверхностей включают фюзеляжи самолетов, обводы судов, кузова автомобилей

\textit{Недостаток поверхностной модели} --- отсутствует информация, о том, с какой стороны поверхности находится материал, а с какой пустота.

\subsection{Твердотельная модель}

Твердотельное моделирование представляет собой наиболее всесторонний и точный метод создания виртуального аналога реального объекта. В результате применения данного метода формируется монолитная модель будущего изделия, включающая в себя такие элементы как линии, грани и, что особенно важно, образует зону поверхности в рамках геометрической формы объекта с такими ключевыми характеристиками как масса и объем \cite{model_geom_01}.

\textbf{Преимущества твердотельных моделей:}
\begin{enumerate}
	\item полное определение объемной формы с возможностью разграничивать внутренний и внешние области объекта;
	\item  обеспечение автоматического удаления скрытых линий;
	\item автоматическое построение 3D разрезов компонентов, что особенно важно при анализе сложных сборочных изделий;
	\item  применение методов анализа с автоматическим получением изображения точных весовых характеристик методом конечных элементов;
	\item получение тоновых эффектов, манипуляции с источниками
	света \cite{model_geom_01}.
\end{enumerate}


\subsection{Выбор определения моделей} % мб не надо 
В контексте представленной задачи наиболее оптимальным выбором являются поверхностные модели объектов. Поверхностные модели позволяют детализировать геометрическую форму объекта, минуя углубленное рассмотрение его внутренней структуры и свойств материалов. Данный подход находит свое применение в ситуациях, когда специфика материала объекта не влияет на проводимый анализ. Так, не требуется тратить ресурсы на моделирование внутренних особенностей и характеристик материала, что делает использование поверхностных моделей более рациональным. Каркасные модели в данном контексте не подходят из-за неполноты представления формы объекта, в то время как твердотельные модели избыточны из-за детальности, не требуемой для задачи


\section{Способы представления трехмерных поверхностей}

Для представления трехмерных поверхностей существуют два широко используемых метода:

\begin{itemize}
	\item \textit{метод полигональных сеток:} этот метод представляет объект в виде связанной между собой сетки плоских многоугольников, это заметно на рисунке  \ref{img-mod3}. Несмотря на его простоту и удобство для описания некоторых типов объектов, например, архитектурных конструкций, метод имеет ограниченную точность, особенно в случаях сложных или криволинейных форм;
	\item \textit{метод параметрических бикубических кусков: }этот подход использует математические формулы, описывающие координаты поверхностей. Эти уравнения имеют два параметра и варьируются по степеням не выше третьей. Этот подход обеспечивает высокую точность при описании поверхности и требует меньше элементов для описания сложных форм, в сравнении с полигональными сетками \cite{model_geom}.
\end{itemize}

Исходя из требований к простоте моделирования, экономии ресурсов и приемлемой детализации для задачи макетирования загородной среды, метод полигональных сеток является оптимальным выбором. Благодаря геометрической простоте, он подходит для представления основных элементов и обеспечивает рациональное использование вычислительных ресурсов. При этом, уровень детализации соответствует требованиям проекта, не делая необходимым применение более сложных методов моделирования.

\img{90mm}{mod3}{Пример полигональной сетки, изображающей кролика.} 


\subsection{Способы описания полигональных сеток}

Существует несколько способов описания полигональных сеток, каждый из которых имеет свои преимущества и недостатки в зависимости от конкретных требований и ограничений приложения.

 \textbf{Наиболее распространенные методы представления полигональных сеток, рассматриваются в \cite{polygon_mesh}:}
 
\begin{enumerate}
	\item \textbf{\textit{список граней}} ---  один из наиболее распространенных подходов к представлению трехмерных моделей, представляет объект как множество граней и множество вершин. В каждую грань входят как минимум 3 вершины, пример рисунок  \ref{img-vf};
	   
  	\textbf{Преимущества использования списка граней:}
  
	\begin{itemize}
		\item \textit{простота поиска вершин грани: }благодаря тому, что список всех граней содержит информацию обо всех связанных вершинах, поиск вершин грани облегчается;
		\item \textit{возможность динамического обновления формы}: используя графический процессор, форма может быть обновлена динамически без обновления связности граней.
	\end{itemize}
			 	
	\textbf{Недостатки использования списка граней:}
	
	\begin{itemize}
	\item\textit{трудности при выполнении операций разрыва и объединения граней:} недостаток явной информации о связях между гранями может усложнить выполнение таких операций;
	\item \textit{проблемы с поиском граней: }в силу отсутствия явно заданных ребер, поиск всех граней может стать затруднительным.
	\end{itemize}
		
	\img{50mm}{vf}{Список граней} 
	
	\item \textit{\textbf{вершинное представление}} --- это метод представления модели через коллекцию вершин, которые связаны между собой, пример рисунок  \ref{img-vf1};
	
	\img{50mm}{vf1}{Вершинное представление}
	
	\textbf{Преимущества использования вершинного представления:}
	
	\begin{itemize}
		\item \textit{простота}: вершинное представление является наиболее базовым и простым способом представления трехмерной модели.
	\end{itemize}

	\textbf{Недостатки использования вершинного представления:}

	\begin{itemize}
		\item \textit{отсутствие явного выражения информации о гранях и ребрах:} для генерации списка граней для визуализации, требуется пройти по всем данным;
		\item \textit{редкое использование: }из-за ограниченности функционала, вершинное представление редко используется в современных системах визуализации.
	\end{itemize}
	
	
	
	\item \textit{\textbf{<<крылатое>> представление}} --- это метод представления модели, который решает проблему перехода от ребра к ребру, путем упорядочивания множества граней вокруг каждого ребра, пример рисунок \ref{img-vf2};
	
	\img{60mm}{vf2}{<<крылатое>> представление}
	
	\textbf{Преимущества использования <<крылатого>> представления:}

	\begin{itemize}
		\item поддержка сложных операций: <<крылатое>> представление подходит для операций подразделения поверхностей и интерактивного моделирования, благодаря своей уникальной структуре.
		\end{itemize}

	\textbf{недостатки использования <<крылатого>> представления:}

	\begin{itemize}
		\item высокие требования к памяти: увеличивающаяся сложность структуры приводит к увеличению объема занимаемой памяти при использовании данного представления.
	\end{itemize}
	

\end{enumerate}


\subsection{Выбор способа описания полигональной сетки} % мб не надо 

В своей работе я выбрал подход к представлению моделей с использованием списка граней, поскольку он предлагает ясное описание граней и удобный доступ к элементам сетки. Список граней позволяет легко и эффективно модифицировать модели, включая добавление, удаление и изменение граней, вершин и ребер. %Благодаря этому методу, я могу выполнять различные операции, такие как вычисление нормалей.

% Важно учесть, что, несмотря на высокую степень гибкости и удобства работы, использование списка граней может потребовать больше памяти по сравнению с другими методами. Однако, учитывая доступные ресурсы памяти и объем моделей, с которыми я работаю, преимущества этого подхода перевешивают его потенциальные недостатки.



\section{Формализация объектов сцены}
 
После изучения и выбора наиболее эффективных методов определения моделей, а именно: использование поверхностных моделей для описания трехмерных объектов, метода полигональных сеток в качестве способа представления трехмерных поверхностей, а также методики описания полигональных сеток с использованием списка граней, мы можем переходить к конкретизации объектов сцены.

\subsection{Сцена}
Сцена представляет собой прямоугольный параллелепипед с определенной сеткой, на которой располагаются модели. У сцены есть только одна сторона, на которой можно размещать модели. Пользователь задает границы сцены, указывая количество квадратов в ширину и длину. Величина каждого квадрата константна и определяется программно. Цвет сцены - светло-зеленый. В программе присутствует ограничение на размер сцены.


\subsection{Объекты сцены}

\begin{enumerate}
\item \textbf{дома}: каждый дом формируется четырьмя стенами, крышей, окнами и дверью. В программе доступны два вида домов:

\begin{itemize}
	\item \textit{<<стандартный>> дом:} одноэтажное здание, занимающее три квадрата на сцене в длину, два квадрата в ширину;
	\item \textit{<<премиальный>> дом:} двухэтажное сооружение с гаражом, занимающее три квадрата сцены в ширину и в длину. Гараж включает в себя стены, крышу и ворота.
\end{itemize}

 \textbf{Компоненты дома}: каждый дом это цельный объект, но состоит из нескольких компонентов:
\begin{itemize}
	\item стены: формируются вертикальными плоскостями, бежевого цвета;
	\item окна: расположены в середине стены, окрашены в голубой цвет;
	\item крыша: составлена из двух треугольников и двух трапеций, коричневого цвета;
	\item дверь: расположена посередине стены, коричневого цвета;
	\item ворота: расположены на двух ячейках стены, коричневого цвета.
\end{itemize}

\item \textbf{дороги}: занимают один квадрат сцены по ширине и длине и темно-серый цвет;
\item \textbf{тротуары}: по форме и размеру аналогичны дорогам, но окрашены в светло-серый цвет;
\item \textbf{машины}:  цельный объект из четырех колес, шести стекол и кузова. В программе имеется выбор модели машины,  различного цвета. \textbf{Компоненты машины: }

\begin{itemize}
	\item \textit{кузов: }формируется набором плоскостей, имитирующих реальные автомобили. Цвет кузова --- красный или серый;
	\item \textit{колеса:} представляют собой цилиндрические объекты, черного цвета;
	\item \textit{Окна:} плоские объекты, встроенные в кузов автомобиля, голубого цвета.
\end{itemize}

\item \textbf{деревья}: состоят из листвы и ствола, представляют цельный объект сцены и занимают одну клетки сцены. Листва имеет зеленый цвет, а ствол --- коричневый;
\item \textbf{кусты}: схожи с деревьями, но без ствола. Занимают одну клетку сцены, листва имеет светло-зеленый оттенок.
\end{enumerate}

Все возможные модели заранее определены, при этом программа не позволяет добавлять новые модели или модифицировать существующие. Однако, в программном обеспечении предусмотрена возможность перемещения или удаления объектов на сцене. Также имеется ограничения на размещение моделей на сцене, а именно, машина может размещаться только на дороге. Дома, дороги, тротуары, деревья и кусты могут размещаться только на свободных участках сцены.


\subsection{Источник света}

Для моделирования освещения в компьютерной графике обычно используются три основных типа источников света: точечные, направленные и общий свет (Ambient Light) \cite{light}. В данной работе выбор сделан в пользу точечного источника света.

Точечный источник света излучает свет равномерно во все стороны из определенной точки в 3D-пространстве, что позволяет эффективно управлять освещением и тенями на сцене, учитывая положение объектов относительно источника света. Положение источника света устанавливается относительно текущей точки наблюдения с помощью последовательных поворотов по осям X и Y \cite{light}

\section{Алгоритмы удаления скрытых линий и поверхностей}

В компьютерной графике алгоритмы удаления невидимых линий и поверхностей относятся к наиболее сложным задачам. Это связано с тем, что они помогают определить видимые для наблюдателя элементы сцены из определенной точки пространства. Сложность этой задачи приводит к тому, что идеального общего решения не существует. Вместо этого, для каждой конкретной задачи требуется подбирать наиболее эффективный подход \cite{del_line}.

%Алгоритмы удаления невидимых линий или поверхностей включают в себя сортировку. Ключевая идея сортировки по расстоянию заключается в том, что объекты, находящиеся дальше от точки наблюдения, вероятнее могут быть заслонены объектами, расположенными ближе к наблюдателю. После определения приоритетов в глубине пространства проводится дополнительная сортировка для определения относительного положения объектов \cite{del_line}.

Алгоритмы удаления невидимых частей сцены можно классифицировать на основании следующих критериев:

\begin{enumerate}
	\item \textit{выбор удаляемых частей:} возможно удаление невидимых линий, ребер, поверхностей, объемов;
	\item \textit{порядок обработки элементов сцены}: удаление может происходить в порядке, определяемом процессом визуализации, или в произвольном порядке;
	\item зависимость от системы координат: существуют алгоритмы, работающие в пространстве объектов, где каждая из $N$ граней объекта сравнивается с остальными $N - 1$ гранями (объем вычислений растет как $N^2$); а также алгоритмы, работающие в пространстве изображения, когда для каждого пикселя изображения определяется, какая из N граней объекта видна (при разрешении экрана $M\times{M}$ объем вычислений растет как $M^2 \times N$) \cite{del_line}.
\end{enumerate}

\subsection{Алгоритм Робертса}

Алгоритм Робертса (1963 год) используется для работы с выпуклыми объектами в 3D пространстве. Объекты представляются как многогранники, полученные пересечением плоскостей. Каждый объект описывается списком граней, образованных ребрами и вершинами. Перед определением видимости удаляются нелицевые плоскости. Затем происходит сравнение каждого ребра с каждым объектом, что ведет к значительному объему вычислений. Таким образом, объем вычислений растет как квадрат числа объектов в сцене. В завершении вычисляются новые ребра от пересечения объектов. Преимущества ---  использование мощных и точных математических методов, также алгоритм прост для понимания. \cite{del_line}. 

\subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта чаще всего применяется для удаления невидимых линий при трехмерном представлении функций, описывающих поверхность в виде $F(x, y, z) = 0$ \cite{del_line}.

Однако, так как в данной программе поверхности не представлены в виде функций, данный метод не подходит.

\subsection{Z-буферный алгоритм удаления поверхностей}

Был введен Эдом Кэтмулом и представляет собой расширение обычного буфера кадра, который хранит цвета каждого пикселя. В Z-буферном алгоритме, дополнительно к каждому пикселю присваивается значение глубины или Z-координата. При добавлении нового пикселя в буфер, сравнивается его Z-координата с той, что уже находится в буфере. Если новый пиксель ближе к наблюдателю (т.е. его Z-координата больше), его атрибуты и Z-координата записываются в буфер. Пример работы алгоритма на рисунке \ref{img-exz}. Этот алгоритм прост в использовании, но требует большого объема памяти для реализации \cite{del_line}. 

\img{70mm}{exz}{Работа алгоритма с Z-буфером} 

\textbf{Преимущества Z-буферного алгоритма:}
\begin{itemize}
\item поддерживает сцены произвольной сложности;
\item отсутствует необходимость в сортировке, что требуется в других алгоритмах;
\item вычислительная сложность линейно зависит от числа анализируемых поверхностей.
\end{itemize}

\textbf{Недостатки Z-буферного алгоритма:}
\begin{itemize}
\item требует значительного объема памяти для буферов.
\item реализация эффектов прозрачности и освещения может быть трудоемкой.
\end{itemize}

%Так как используемый источник освещения является точечным, то есть излучающим свет во всех направлениях, то для генерации теней необходимо произвести построение сцены 6 раз для разных направлений камеры: вдоль и против осей OX, OY и OZ. В результате образуется так называемая кубическая карта теней, в которой содержатся значения глубин всех освещенных участков сцены. 
%Этот способ генерации теней требует значительного числа вычислений, однако они выполняются только при перестроении сцены, то есть при изменении положения камеры заново вычислять значения в карте теней не нужно. Таким образом метод кубической карты теней позволяет сохранить плавность подачи картинки при перемещении по сцене, поэтому используется в данном курсовом проекте.



\subsection{Алгоритм, использующий список приоритетов.}

Алгоритмы, использующие список приоритетов, предполагают предварительную сортировку элементов по глубине. Запись в буфер кадра происходит начиная с наиболее удаленных от наблюдателя элементов. Ближе расположенные элементы последующим образом перезаписывают информацию в буфере. Взаимодействие прозрачных элементов с буфером осуществляется через частичную корректировку его содержимого, учитывая атрибуты прозрачности. Подход известен как <<алгоритм художника>>. Это аналогия с тем, как художник создает картину: сначала фон, затем средний план, и в конце передний план. Алгоритм художника --- простейший программный вариант решения «проблемы видимости» \cite{light, del_line}. 

Однако, этот подход имеет недостатки:
\begin{itemize}
\item \textit{масштабируемость:} временная сложность алгоритма художника сильно зависит от алгоритма сортировки. Это делает подход более подходящим для малых сцен;
\item \textit{требование к памяти}: алгоритм требует информацию обо всем списке треугольников, что потребляет значительное количество памяти и исключает возможность потоковой реализации рендеринга;
\item \textit{неопределенность порядка}: алгоритм может дать сбой в некоторых случаях, включая циклическое перекрытие или проникновение многоугольников \cite{light}.
\end{itemize}

\subsection{Алгоритм Варнока}

Алгоритм Варнока использует принцип когерентности, по которому большие области изображения однородны, и работает в пространстве изображения. Основная идея - разбивать окно на подокна до тех пор, пока их содержимое не станет достаточно простым для визуализации, или размер подокна не достигнет заданного предела разрешения \cite{del_line, varnok}

Конкретная реализация зависит от метода разбиения окна и 
критерия, определяющего простоту содержимого окна.
\begin{itemize}
\item в оригинальной версии алгоритма окно делится на четыре равных по размеру подокна;
\item вариант Вейлера и Азертона предполагает разбиение окна по ребрам изображаемых многоугольников \cite{varnok}.
\end{itemize}

Эффективность данного алгоритма зависит от сложности сцены. Использование полигональной сетки может замедлить его выполнение.


\subsection{Алгоритм прямой и обратной трассировки лучей}

Методы прямой и обратной трассировки лучей используются для отслеживания траектории лучей от источника света до камеры, учитывая взаимодействие с объектами на пути. 

\begin{itemize}
	\item \textbf{прямая трассировка лучей}: строит траектории лучей от всех источников света до всех точек сцены, включая те, которые не попадают в камеру. Из-за этого, метод считается неэффективным;
	
	\item \textbf{обратная трассировка лучей}: эффективнее, учитывая взаимное влияние объектов друг на друга. Позволяет рассчитывать тени, многократные отражения и преломления. Согласно этому методу отслеживание лучей осуществляется не от источников света, а в обратном направлении --- от точки наблюдения. Так учитываются только те лучи, которые вносят вклад в формирование изображения, примерная схема обратной трассировки лучей на рисунке \ref{img-lightback}. Однако имеет недостатки в виде неучета вторичного освещения, высокой вычислительной стоимости, резких границ цветовых переходов и дискретности первичных лучей \cite{ray_tracing}.
	
\end{itemize}
 
 
\subsection{Выбор алгоритма удаления скрытых линий и поверхностей}


Для наглядности эффективности алгоритмов была составлена таблица \ref{table:1}, в строке : <<Вычислительная сложность>> $N$ и $С$ означают, количество граней и количество пикселей, соответственно.


\begin{table}[h!]
	\centering
	\caption{\raggedleft Сравнение алгоритмов удаления невидимых линий и поверхностей.}\label{table:1}
	\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
		\hline
		& \textbf{z-буфер} & \textbf{Обратная трассировка лучей} & \textbf{Варнок} & \textbf{Робертс} \\
		\hline
		\textbf{Вычисл. сложность} & $O(CN)$ & $O(CN)$ & $O(CN)$ & $O(N^2)$ \\
		\hline
		\textbf{Рабочее пространство} & Изображение & Изображение & Изображение & Объектное \\
		\hline
		\textbf{Трудность \newline реализации} & Низкая & Средняя & Средняя & Высокая \\
		\hline
		\textbf{Производит. при сложной сцене} & Высокая & Низкая & Средняя & Низкая \\
		\hline
		\textbf{Распростран. в современном ПО} & Высокая & Высокая & Низкая & Низкая \\
		\hline
		\textbf{Использов. рекурсивных вызовов} & Нет & Да & ДА & Нет \\
		\hline
	\end{tabularx}
\end{table}


 \img{70mm}{lightback}{Схема обратной трассировки лучей} 


На основании рассмотренных алгоритмов, я пришел к выводу, что  Алгоритм Z-буфера представляет собой оптимальный выбор для удаления невидимых линий и поверхностей. Он обеспечивает быструю обработку сцен любой сложности и адаптируется под изменения в освещении и закраске. При небольшом размере изображения Z-буфер эффективно обрабатывает большое количество объектов без проблем с памятью. Благодаря простоте понимания и отладки, алгоритм Z-буфера является доступным и эффективным решением для данной задачи.


\section{Модель освещения}

Модели освещения классифицируются на глобальные и локальные. Глобальные модели анализируют отражение и преломление света от объектов, не являющихся прямыми источниками освещения, что требует значительных вычислительных затрат. В данной работе применяются локальные модели, ограничивающиеся учетом света только от прямых источников. Среди них выделяются модель Ламберта и модель Фонга \cite{lightmod}.


\subsection{Простая модель}

Простейшая модель освещения складывается из трех основных компонентов светового воздействия, например рисунок \ref{img-light}.

\img{35mm}{light}{Пример суммарного освещения.} 

Формула для расчета простой модели освещения \cite{lightmodf}:
\begin{equation}
 I = I_{a} + I_{d} + I_{s}
\end{equation}
	
\begin{itemize}
	\item $I_{a}$ --- фоновая компонента;
	\item $I_{d}$ --- диффузная компонента;
	\item $I_{s}$ --- зеркальная компонента.
\end{itemize}

\textit{Фоновая компонента} освещения представляет собой константу, добавляемую к освещенности в каждой точке. Формула для расчета фоновой компоненты освещения приведена ниже \cite{lightmodf} : \begin{equation}
	I_{a}=k_{a} \cdot i_{a}
\end{equation}
\begin{itemize}
	\item $I_{a}$ --- фоновая компонента освещения в точке;
	\item $k_{a}$​ --- коэффициент, характеризующий способность материала воспринимать фоновое освещение;
	\item $i_{a}$​ --- интенсивность фонового освещения.
\end{itemize}

Как видно из приведенного выше уравнения, фоновая компонента освещения не зависит от пространственных координат освещаемой точки и источника света.

%
%\textit{Диффузная компонента} модели освещения предполагает, что свет отражается от поверхности с одинаковой интенсивностью во всех направлениях полусферы, повёрнутой наружу относительно поверхности. Эта составляющая расчётов основана на законе Ламберта и выражается формулой  \cite{lightmodf}:
%
%\begin{equation}
%	I_{diff}=I_{d} \cdot k_{diff} \cdot cos(\theta)
%\end{equation}
%
%
%\begin{itemize}
%	\item $I_{diff}​$ --- диффузная составляющая освещённости,
%	\item $I_{d}$​ --- интенсивность падающего светового луча,
%	\item $k_{diff}​$ --- коэффициент диффузного отражения,
%	\item $\theta$ --- угол падения светового луча.
%\end{itemize}

%
%
%\textit{Зеркальная компонента} модели освещения описывает свойства отражения поверхности, позволяя моделировать блики на ней. Она зависит от близости направлений к отраженному лучу и наблюдателю, которая может быть описана формулой \cite{lightmodf}:
%
%\begin{equation}
%	I_{s}=k_{s} \cdot cos^{\alpha}(R, V) \cdot i_{s} = k_{s} \cdot (R, V)^{\alpha} \cdot i_{s}
%\end{equation}
%
%\begin{itemize}
%	\item 	$I_{s}$​ --- зеркальная компонента освещенности.
%	\item $k_{s}$​ --- коэффициент зеркального отражения.
%	\item $i_{s}$​ --- интенсивность зеркального освещения.
%	\item $R$ --- вектор отраженного луча.
%	\item $V$ --- вектор направления к наблюдателю.
%	\item $\alpha$ ---коэффициент блеска, характеризующий материал поверхности.
%\end{itemize}

\subsection{Модель Ламберта}

Модель Ламберта описывает идеальное диффузное освещение, где свет рассеивается равномерно во все стороны после попадания на поверхность. \cite{lightmodf} Она учитывает только ориентацию поверхности (вектор нормали $N$) и направление на источник света $L$. Диффузионное составляющая освещенности вычисляется по закону Ламберта, с использованием косинуса угла между $L$ и $N$, как показано ниже в формуле \cite{lightmod}:


\begin{equation}\label{lamber}
	I_{diff}=I_{d} \cdot k_{diff} \cdot \cos{\cdot (\vec L \cdot \vec N)}
\end{equation}

\begin{itemize}
	\item $I_{diff}​$ --- диффузная составляющая освещенности;
	\item $I_{d}$​ --- интенсивность рассеянного света;
	\item $k_{diff}​$ --- коэффициент диффузного отражения;
	\item $\vec L$ -- вектор, направлен из точки на источник;
	\item $\vec N$ --- вектор нормали к точке.
\end{itemize}

\img{50mm}{lamber}{Модель Ламберта} 

Однако, как показывает формула \ref{lamber}, у этой модели есть значительный недостаток: она предполагает одинаковую интенсивность света на всей грани, не учитывая положение наблюдателя


\subsection{Модель Фонга}
 
 Модель Фонга, объединяющая диффузную (по Ламберту) и зеркальную составляющие, обеспечивает не только равномерное освещение материала, но и возможность появления блика, местоположение которого определяется законом равенства углов падения и отражения \cite{lightmod}. Яркость увеличивается, когда наблюдатель находится близко к углам отражения. Падающий и отраженный лучи лежат в одной плоскости с нормалью к отражающей поверхности в точке падения, и эта нормаль делит угол между лучами на две равные части как показано на рисунке \ref{img-lamber1}.
 
\img{50mm}{lamber1}{Модель Фонга} 

\begin{equation}
	I_{s}=k_{s} \cdot cos^{\alpha}(\vec R, \vec V) \cdot i_{s} = k_{s} \cdot (\vec R, \vec V)^{\alpha} \cdot i_{s}
\end{equation}

\begin{itemize}
	\item $I_{s}$​ --- зеркальная компонента освещенности;
	\item $k_{s}$​ --- коэффициент зеркального отражения;
	\item $i_{s}$​ --- интенсивность зеркального освещения;
	\item $\vec R$ --- вектор отраженного луча;
	\item $\vec V$ --- вектор направления к наблюдателю;
	\item $\alpha$ ---коэффициент блеска, характеризующий материал поверхности.
\end{itemize}


Использование модели Ламберта в моей работе обусловлено её вычислительной эффективностью и простотой, что позволяет быстро и точно моделировать диффузное освещение.

\section{Алгоритмы построения теней}

\subsection{Модификация  Z-буфера}
В алгоритмах отображения сцены можно адаптировать Z-буфер для отслеживания теней. Изначально, этот буфер хранит данные о глубине каждого пикселя, но для точного отображения теней нужен дополнительный этап.

Первым шагом камера устанавливается на место источника света, позволяя занести данные о глубине каждой точки в теневой буфер. Это гарантирует, что все отмеченные точки расцениваются как освещенные \cite{letion}.

Далее формируется изображение с точки зрения наблюдателя. На этом этапе каждый пиксель анализируется с учетом его расстояния до источника света и сопоставляется с данными из теневой карты. Если расстояние до пикселя больше значения из теневой карты, пиксель считается находящимся в тени и отображается с акцентом на рассеянном свете, это можно увидеть на примере рисунка \ref{img-zb}, точка $ B $ имеет большее расстояние до источника света, чем восстановленный из карты теней, следовательно точка $ B $ будет в тени, а точка $ A $  находится на том же расстоянии от источника света, что и восстановлено из карты теней и не будет затемнена. В итоге, модификация Z-буфера позволяет эффективно учесть тени при рендеринге сцены, одновременно выполняя удаление невидимых поверхностей \cite{letion}.






\subsection{Модификация Вейлера-Азертона}

На первом шаге с помощью алгоритма удаления невидимых поверхностей выбираются освещенные грани, т. е. грани, которые видны из положения источника света. Для увеличения эффективности, в памяти хранятся именно эти грани, что позволяет избежать удвоения обрабатываемых граней для выпуклого многоугольника. Освещенные многоугольники помечаются и преобразуются к исходной ориентации, где они приписываются к своим прототипам в качестве многоугольников детализации поверхности. Чтобы избежать появления ложных теней, сцену рассматривают в пределах видимого или отсекающего объема, определенного положением источника света \cite{letion}.

На втором шаге объединенные данные о многоугольниках обрабатываются из положения наблюдателя. Если какая-то часть не освещена, применяется соответствующее правило затенения. Если источников света несколько, то используется несколько наборов освещенных граней \cite{letion}.
\end{enumerate}

\img{80mm}{zb}{Пример определения тени, алгоритмом модификации Z-буфера.} 

Выбор модифицированного Z-буфера для построения теней в данном контексте является оптимальным. Это обусловлено его эффективностью и совместимостью с уже используемым Z-буфером для удаления невидимых поверхностей. Использование одной и той же технологии упрощает интеграцию и обеспечивает более быструю и эффективную обработку графической информации.


\section{Вывод}

Анализ подходов к заданию трехмерных моделей привел к выбору поверхностных моделей. Для удаления невидимых ребер применен алгоритм Z-буфера. Модификация Z-буфера использована для построения теней, обеспечивая совместимость и упрощенную интеграцию. Представление моделей основано на списке граней, облегчающем модификацию. В задаче макетирования загородной среды применены полигональные сетки и поверхностные модели для эффективного использования ресурсов.